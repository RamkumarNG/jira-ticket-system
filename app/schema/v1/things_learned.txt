1. async postgresql for fastAPI offers more adv
    1.1 AsyncSession
    1.2 create_async_engine
    1.3 sessionmaker
    1.4 depends
    1.5 @asynccontextmanager
    1.6 lifespan

2. add middleware using BaseHTTPMiddleware from starlette

3. api_router to inlcude routers

4. model_registry, dataclass while defining tables using Class
    4.1 -> relationship() can be used to create relations to other tables
        4.1.1 -> first arg -> table name
        4.1.2  one to many -> https://docs.sqlalchemy.org/en/20/orm/basic_relationships.html#declarative-vs-imperative-forms
        4.1.3 -> may to one -> https://docs.sqlalchemy.org/en/20/orm/basic_relationships.html#declarative-vs-imperative-forms
        4.1.4 -> many to many -> https://docs.sqlalchemy.org/en/20/orm/basic_relationships.html#declarative-vs-imperative-forms
        4.1.5 -> one to one -> https://docs.sqlalchemy.org/en/20/orm/basic_relationships.html#declarative-vs-imperative-forms
        4.1.6 -> back_populates -> Sqlalchemy knows these two fields are related now
                                -> if youve defined the relationship's separately, but didn't provide a back_populates argument,
                                    modifying one field wouldn't automatically update the other in your transaction.
    4.2 - > persistent state in SQLAlchemy

5. while returning API reposne,
    5.1 either return pydantich model (FastAPi will serilizae to json automatically) or
    5.2 or if u are using JsonResponse, make sure u do response.dict() or jsonable_encoder(response)
    5.3 When to Use Each
        Use response.dict() when:
        You're working with a Pydantic model.
        You need a simple dictionary representation of a Pydantic model's data.
        You dont need to handle complex, non-serializable types like UUID, datetime, etc.
    5.4 Use jsonable_encoder(response) when:
        You need to convert complex objects (including Pydantic models, SQLAlchemy models, etc.) into a JSON-serializable format.
        You are working with non-serializable types (e.g., UUID, datetime, Decimal) that need to be converted into something JSON can handle.
        You want to ensure compatibility with FastAPI's JSONResponse and other tools that require JSON-serializable data.

6. migration
    6.1 -> make use of alembic package to generate migration files
    6.2 -> once alembic init, make sure of using sync psycopg2 bcz we dont need async here
    6.3 -> commit files to repo and run in prod or env
